import json
import structlog
from datetime import datetime, timezone
from typing import Optional, List, Dict, Tuple
from sqlalchemy.orm import Session
from .bitcoin_rpc import BitcoinRPCService
from .parser import BRC20Parser
from .validator import BRC20Validator
from .utxo_service import UTXOResolutionService
from src.models.balance import Balance
from src.models.deploy import Deploy
from src.models.transaction import BRC20Operation
from src.utils.exceptions import (
    BRC20Exception,
    BRC20ErrorCodes,
    ValidationResult,
    TransferType,
)
from src.utils.bitcoin import (
    extract_signature_from_input,
    is_sighash_single_anyonecanpay,
)


class ProcessingResult:
    def __init__(self):
        self.operation_found = False
        self.is_valid = False
        self.error_message = None
        self.error_code = None
        self.operation_type = None
        self.ticker = None
        self.amount = None
        self.txid = None


class BRC20Processor:
    def __init__(self, db_session: Session, bitcoin_rpc: BitcoinRPCService):
        self.db = db_session
        self.rpc = bitcoin_rpc
        self.parser = BRC20Parser()
        self.validator = BRC20Validator(db_session)
        self.utxo_service = UTXOResolutionService(bitcoin_rpc)
        self.logger = structlog.get_logger()
        self.current_block_timestamp = None

    def _convert_block_timestamp(self, block_timestamp: int) -> datetime:
        if not isinstance(block_timestamp, int) or block_timestamp <= 0:
            raise ValueError(f"Invalid block timestamp: {block_timestamp}")
        return datetime.fromtimestamp(block_timestamp, tz=timezone.utc)

    def process_transaction(
        self,
        tx: dict,
        block_height: int,
        tx_index: int,
        block_timestamp: int,
        block_hash: str,
        intermediate_balances=None,
        intermediate_total_minted=None,
        intermediate_deploys=None,
    ) -> ProcessingResult:
        multi_transfer_ops = self.parser.extract_multi_transfer_op_returns(tx)
        if len(multi_transfer_ops) > 1:
            return self.process_multi_transfer(
                tx,
                block_height,
                tx_index,
                block_timestamp,
                block_hash,
                multi_transfer_ops,
                intermediate_balances,
            )

        result = ProcessingResult()
        result.txid = tx.get("txid", "unknown")
        hex_data, vout_index = self.parser.extract_op_return_data(tx)
        if not hex_data:
            return result
        if vout_index is None:
            vout_index = 0
        parse_result = self.parser.parse_brc20_operation(hex_data)
        if not parse_result["success"]:
            if parse_result.get("error_code") != BRC20ErrorCodes.INVALID_JSON:
                tx.update(
                    {
                        "block_height": block_height,
                        "tx_index": tx_index,
                        "block_hash": block_hash,
                        "vout_index": vout_index,
                    }
                )
                self.current_block_timestamp = block_timestamp
                self.log_operation(
                    op_data={"op": "invalid"},
                    val_res=ValidationResult(
                        False,
                        parse_result.get("error_code"),
                        parse_result.get("error_message"),
                    ),
                    tx_info=tx,
                    raw_op=hex_data,
                )
            return result
        try:
            tx.update(
                {
                    "block_height": block_height,
                    "tx_index": tx_index,
                    "block_hash": block_hash,
                    "vout_index": vout_index,
                }
            )
            self.current_block_timestamp = block_timestamp
            result.operation_found = True
            operation_data = parse_result["data"]
            if operation_data.get("tick"):
                operation_data["tick"] = operation_data["tick"].upper()
            op_type = operation_data.get("op")
            sender_address = self.get_first_input_address(tx)
            validation_result = self.validator.validate_complete_operation(
                operation_data,
                tx.get("vout", []),
                sender_address,
                intermediate_balances=intermediate_balances,
                intermediate_total_minted=intermediate_total_minted,
                intermediate_deploys=intermediate_deploys,
            )
            is_marketplace = False
            if validation_result.is_valid:
                if op_type == "deploy":
                    self.process_deploy(operation_data, tx, intermediate_deploys=intermediate_deploys)
                elif op_type == "mint":
                    self.process_mint(
                        operation_data,
                        tx,
                        intermediate_balances=intermediate_balances,
                        intermediate_total_minted=intermediate_total_minted,
                        intermediate_deploys=intermediate_deploys,
                    )
                elif op_type == "transfer":
                    if self.classify_transfer_type(tx, block_height) == TransferType.MARKETPLACE:
                        is_marketplace = True
                    validation_result = self.process_transfer(
                        operation_data,
                        tx,
                        validation_result,
                        hex_data,
                        block_height,
                        intermediate_balances=intermediate_balances,
                    )
            result.is_valid = validation_result.is_valid
            result.error_code = validation_result.error_code
            result.error_message = validation_result.error_message
            result.operation_type = op_type
            result.ticker = operation_data.get("tick")
            result.amount = operation_data.get("amt")
            self.log_operation(
                operation_data,
                validation_result,
                tx,
                hex_data,
                json.dumps(operation_data),
                is_marketplace,
            )
        except Exception as e:
            self.logger.error(
                "Unhandled exception in BRC20Processor",
                txid=result.txid,
                error=str(e),
                exc_info=True,
            )
            result.is_valid = False
            result.error_code = "UNHANDLED_EXCEPTION"
            result.error_message = str(e)
        return result

    def process_deploy(
        self,
        operation: dict,
        tx_info: dict,
        intermediate_deploys: Optional[Dict] = None,
    ):
        deploy = Deploy(
            ticker=operation["tick"].upper(),
            max_supply=operation["m"],
            limit_per_op=operation.get("l"),
            deploy_txid=tx_info["txid"],
            deploy_height=tx_info["block_height"],
            deploy_timestamp=self._convert_block_timestamp(self.current_block_timestamp),
            deployer_address=self.get_first_input_address(tx_info),
        )
        self.db.add(deploy)
        if intermediate_deploys is not None:
            intermediate_deploys[deploy.ticker] = deploy

    def process_mint(
        self,
        operation: dict,
        tx_info: dict,
        intermediate_balances: Optional[Dict] = None,
        intermediate_total_minted: Optional[Dict] = None,
        intermediate_deploys: Optional[Dict] = None,
    ):
        ticker = operation["tick"].upper()
        amount = operation["amt"]
        recipient = self.validator.get_output_after_op_return_address(tx_info.get("vout", []))

        deploy = self.validator.get_deploy_record(ticker, intermediate_deploys=intermediate_deploys)
        validation_result = self.validator.validate_mint(
            operation, deploy, intermediate_total_minted=intermediate_total_minted
        )

        if validation_result.is_valid:
            from src.utils.amounts import add_amounts

            if intermediate_total_minted is not None:
                current_minted = self.validator.get_total_minted(ticker, intermediate_total_minted)
                intermediate_total_minted[ticker] = add_amounts(current_minted, amount)

            if recipient:
                self.update_balance(
                    address=recipient,
                    ticker=ticker,
                    amount_delta=amount,
                    op_type="mint",
                    txid=tx_info["txid"],
                    intermediate_balances=intermediate_balances,
                )
        return validation_result

    def process_transfer(
        self,
        operation: dict,
        tx_info: dict,
        validation_result: ValidationResult,
        hex_data: str,
        block_height: int,
        intermediate_balances: Optional[Dict] = None,
    ) -> ValidationResult:
        transfer_type = self.classify_transfer_type(tx_info, block_height)

        if transfer_type == TransferType.INVALID_MARKETPLACE:
            return ValidationResult(
                False,
                BRC20ErrorCodes.INVALID_MARKETPLACE_TRANSACTION,
                "Transaction has a marketplace SIGHASH but does not conform to a valid template.",
            )

        if not validation_result.is_valid:
            return validation_result

        if validation_result.is_valid:
            sender_address = self.get_first_input_address(tx_info)
            recipient_address = self.validator.get_output_after_op_return_address(tx_info.get("vout", []))
            if sender_address and recipient_address:
                self.update_balance(
                    address=sender_address,
                    ticker=operation["tick"],
                    amount_delta=f"-{operation['amt']}",
                    op_type="transfer_out",
                    txid=tx_info["txid"],
                    intermediate_balances=intermediate_balances,
                )
                self.update_balance(
                    address=recipient_address,
                    ticker=operation["tick"],
                    amount_delta=operation["amt"],
                    op_type="transfer_in",
                    txid=tx_info["txid"],
                    intermediate_balances=intermediate_balances,
                )
            else:
                return ValidationResult(
                    False,
                    BRC20ErrorCodes.INVALID_ADDRESS,
                    "Unable to resolve sender or recipient.",
                )
        return validation_result

    def log_operation(
        self,
        op_data,
        val_res,
        tx_info,
        raw_op,
        json_op=None,
        is_mkt=False,
        is_multi_transfer=False,
        multi_transfer_step=None,
    ):
        timestamp = self._convert_block_timestamp(self.current_block_timestamp)
        op_type = op_data.get("op", "invalid")
        from_addr, to_addr = None, None
        if op_type == "deploy":
            from_addr = self.get_first_input_address(tx_info)
        elif op_type == "mint":
            to_addr = self.validator.get_output_after_op_return_address(tx_info.get("vout", []))
        elif op_type == "transfer":
            addrs = self.resolve_transfer_addresses(tx_info)
            from_addr, to_addr = addrs.get("sender"), addrs.get("recipient")
        op = BRC20Operation(
            txid=tx_info["txid"],
            vout_index=tx_info.get("vout_index", 0),
            operation=op_type,
            ticker=op_data.get("tick"),
            amount=op_data.get("amt"),
            from_address=from_addr,
            to_address=to_addr,
            block_height=tx_info["block_height"],
            block_hash=tx_info["block_hash"],
            tx_index=tx_info["tx_index"],
            timestamp=timestamp,
            is_valid=val_res.is_valid,
            error_code=val_res.error_code,
            error_message=val_res.error_message,
            raw_op_return=raw_op,
            parsed_json=json_op,
            is_marketplace=is_mkt,
            is_multi_transfer=is_multi_transfer,
            multi_transfer_step=multi_transfer_step,
        )
        self.db.add(op)

    def update_balance(
        self,
        address,
        ticker,
        amount_delta,
        op_type,
        txid,
        intermediate_balances: Optional[Dict] = None,
    ):
        normalized_ticker = ticker.upper()
        start_balance_str = self.validator.get_balance(address, normalized_ticker, intermediate_balances)
        from src.utils.amounts import add_amounts, subtract_amounts, compare_amounts

        if amount_delta.startswith("-"):
            amount_to_subtract = amount_delta[1:]
            if compare_amounts(start_balance_str, amount_to_subtract) < 0:
                raise BRC20Exception(
                    BRC20ErrorCodes.INSUFFICIENT_BALANCE,
                    f"Insufficient balance for {op_type} for address {address}",
                )
            new_balance_str = subtract_amounts(start_balance_str, amount_to_subtract)
        else:
            new_balance_str = add_amounts(start_balance_str, amount_delta)
        db_balance_obj = Balance.get_or_create(self.db, address, normalized_ticker)
        db_balance_obj.balance = new_balance_str
        if intermediate_balances is not None:
            intermediate_balances[(address, normalized_ticker)] = new_balance_str

    def get_first_input_address(self, tx_info: dict) -> Optional[str]:
        try:
            vin = tx_info.get("vin", [])
            if not vin:
                return None

            first_input = vin[0]
            if "coinbase" in first_input:
                return None

            txid = first_input.get("txid")
            vout = first_input.get("vout")

            if not txid or vout is None:
                return None

            return self.utxo_service.get_input_address(txid, vout)
        except Exception as e:
            self.logger.error(f"Error getting first input address: {e}")
            return None

    def resolve_transfer_addresses(self, tx_info: dict) -> Dict[str, Optional[str]]:
        return {
            "sender": self.get_first_input_address(tx_info),
            "recipient": self.validator.get_output_after_op_return_address(tx_info.get("vout", [])),
        }

    def _validate_early_marketplace_template(self, tx_info: dict) -> ValidationResult:
        inputs = tx_info.get("vin", [])
        if len(inputs) < 3:
            return ValidationResult(
                False,
                BRC20ErrorCodes.INVALID_MARKETPLACE_TRANSACTION,
                "Early marketplace transaction must have at least 3 inputs.",
            )
        sighash_found = False
        for vin in inputs:
            signature_hex = extract_signature_from_input(vin)
            if signature_hex and is_sighash_single_anyonecanpay(signature_hex):
                sighash_found = True
                break
        if not sighash_found:
            return ValidationResult(
                False,
                BRC20ErrorCodes.INVALID_SIGHASH_TYPE,
                "No input with SIGHASH_SINGLE | ANYONECANPAY found.",
            )
        input_addresses = {
            self.utxo_service.get_input_address(vin["txid"], vin["vout"])
            for vin in inputs
            if "txid" in vin and "vout" in vin
        }
        input_addresses.discard(None)
        if len(input_addresses) < 3:
            return ValidationResult(
                False,
                BRC20ErrorCodes.INVALID_MARKETPLACE_TRANSACTION,
                "Early marketplace transaction must involve at least 3 different addresses.",
            )
        return ValidationResult(True)

    def _validate_new_marketplace_template(self, tx_info: dict) -> ValidationResult:
        inputs = tx_info.get("vin", [])
        if len(inputs) < 3:
            return ValidationResult(
                False,
                BRC20ErrorCodes.INVALID_MARKETPLACE_TRANSACTION,
                "Marketplace transaction must have at least 3 inputs.",
            )
        if len(inputs) < 2:
            return ValidationResult(
                False,
                BRC20ErrorCodes.INVALID_MARKETPLACE_TRANSACTION,
                "Marketplace transaction must have at least 2 inputs for template validation.",
            )

        input0_addr = self.utxo_service.get_input_address(inputs[0]["txid"], inputs[0]["vout"])
        input1_addr = self.utxo_service.get_input_address(inputs[1]["txid"], inputs[1]["vout"])

        if not input0_addr or input0_addr != input1_addr:
            return ValidationResult(
                False,
                BRC20ErrorCodes.INVALID_MARKETPLACE_TRANSACTION,
                "First two inputs must be from the same address.",
            )

        sig0_hex = extract_signature_from_input(inputs[0])
        sig1_hex = extract_signature_from_input(inputs[1])

        if not (
            sig0_hex
            and is_sighash_single_anyonecanpay(sig0_hex)
            and sig1_hex
            and is_sighash_single_anyonecanpay(sig1_hex)
        ):
            return ValidationResult(
                False,
                BRC20ErrorCodes.INVALID_SIGHASH_TYPE,
                "First two inputs must use SIGHASH_SINGLE | ANYONECANPAY.",
            )

        input_addresses = {
            self.utxo_service.get_input_address(vin["txid"], vin["vout"])
            for vin in inputs
            if "txid" in vin and "vout" in vin
        }
        input_addresses.discard(None)

        if len(input_addresses) < 3:
            return ValidationResult(
                False,
                BRC20ErrorCodes.INVALID_MARKETPLACE_TRANSACTION,
                "Marketplace transaction must involve at least 3 different addresses.",
            )

        return ValidationResult(True)

    def validate_marketplace_transfer(self, tx_info: dict, block_height: int) -> ValidationResult:
        if block_height < 901350:
            return self._validate_early_marketplace_template(tx_info)
        else:
            return self._validate_new_marketplace_template(tx_info)

    def _has_marketplace_sighash(self, tx_info: dict) -> bool:
        if not tx_info.get("vin"):
            return False
        for vin in tx_info["vin"]:
            signature_hex = extract_signature_from_input(vin)
            if signature_hex and is_sighash_single_anyonecanpay(signature_hex):
                return True
        return False

    def classify_transfer_type(self, tx_info: dict, block_height: int) -> "TransferType":
        if not self._has_marketplace_sighash(tx_info):
            return TransferType.SIMPLE
        marketplace_validation = self.validate_marketplace_transfer(tx_info, block_height)
        if marketplace_validation.is_valid:
            return TransferType.MARKETPLACE
        else:
            return TransferType.INVALID_MARKETPLACE

    def process_multi_transfer(
        self,
        tx: dict,
        block_height: int,
        tx_index: int,
        block_timestamp: int,
        block_hash: str,
        transfer_ops: List[Tuple[str, int]],
        intermediate_balances,
    ) -> ProcessingResult:
        tx_info = tx.copy()
        tx_info.update(
            {
                "block_height": block_height,
                "tx_index": tx_index,
                "block_hash": block_hash,
            }
        )
        self.current_block_timestamp = block_timestamp

        structure_validation = self.parser.validate_multi_transfer_structure(tx, transfer_ops)
        if not structure_validation.is_valid:
            op_data = {"op": "transfer"}  # Placeholder for logging
            self.log_operation(
                op_data,
                structure_validation,
                tx_info,
                transfer_ops,
                is_multi_transfer=True,
            )
            return self._create_processing_result(tx_info["txid"], structure_validation, is_multi=True, op_data=op_data)

        parsed_ops = []
        for hex_data, vout_index in transfer_ops:
            parse_result = self.parser.parse_brc20_operation(hex_data)
            parsed_ops.append((parse_result, vout_index))

        meta_validation, ticker, total_amount = self.parser.validate_multi_transfer_meta_rules(parsed_ops)
        if not meta_validation.is_valid:
            op_data = {"op": "transfer", "tick": "multiple"}  # Placeholder
            self.log_operation(op_data, meta_validation, tx_info, transfer_ops, is_multi_transfer=True)
            return self._create_processing_result(tx_info["txid"], meta_validation, is_multi=True, op_data=op_data)

        sender_address = self.get_first_input_address(tx_info)
        deploy_record = self.validator.get_deploy_record(ticker)

        fake_op = {"tick": ticker, "amt": total_amount}
        sender_balance = self.validator.get_balance(sender_address, ticker, intermediate_balances)
        total_balance_validation = self.validator.validate_transfer(fake_op, sender_balance, deploy_record)

        if not total_balance_validation:
            total_balance_validation.error_code = BRC20ErrorCodes.MULTI_TRANSFER_INSUFFICIENT_TOTAL_BALANCE
            self.log_operation(
                fake_op,
                total_balance_validation,
                tx_info,
                transfer_ops,
                is_multi_transfer=True,
            )
            return self._create_processing_result(
                tx_info["txid"],
                total_balance_validation,
                is_multi=True,
                op_data=fake_op,
            )

        simulated_balances = intermediate_balances.copy() if intermediate_balances is not None else {}
        all_steps_valid = True
        final_validation_result = ValidationResult(True)

        for i, (parse_result, vout_index) in enumerate(parsed_ops):
            if not parse_result["success"]:
                all_steps_valid = False
                final_validation_result = ValidationResult(
                    False, parse_result["error_code"], parse_result["error_message"]
                )
                break

            op_data = parse_result["data"]
            current_sender_balance = self.validator.get_balance(sender_address, op_data["tick"], simulated_balances)
            step_validation = self.validator.validate_transfer(op_data, current_sender_balance, deploy_record)

            if not step_validation.is_valid:
                all_steps_valid = False
                final_validation_result = step_validation
                break

            from src.utils.amounts import subtract_amounts, add_amounts

            recipient_address = self.validator.get_output_after_op_return_address(tx_info.get("vout", [])[vout_index:])
            simulated_balances[(sender_address, ticker)] = subtract_amounts(current_sender_balance, op_data["amt"])
            current_recipient_balance = self.validator.get_balance(recipient_address, ticker, simulated_balances)
            simulated_balances[(recipient_address, ticker)] = add_amounts(current_recipient_balance, op_data["amt"])

        for i, (hex_data, vout_index) in enumerate(transfer_ops):
            op_data = self.parser.parse_brc20_operation(hex_data)["data"]
            tx_info_step = tx_info.copy()
            tx_info_step["vout_index"] = vout_index
            self.log_operation(
                op_data,
                final_validation_result,
                tx_info_step,
                hex_data,
                json.dumps(op_data),
                is_mkt=False,
                is_multi_transfer=True,
                multi_transfer_step=i,
            )

        if all_steps_valid and intermediate_balances is not None:
            intermediate_balances.update(simulated_balances)

        return self._create_processing_result(
            tx_info["txid"],
            final_validation_result,
            is_multi=True,
            op_data={"tick": ticker, "amt": total_amount},
        )

    def _create_processing_result(self, txid, validation_result, is_multi=False, _op_data=None) -> ProcessingResult:
        result = ProcessingResult()
        result.txid = txid
        result.operation_found = True
        result.is_valid = validation_result.is_valid
        result.error_code = validation_result.error_code
        result.error_message = validation_result.error_message
        if _op_data:
            result.operation_type = "multi_transfer" if is_multi else _op_data.get("op")
            result.ticker = _op_data.get("tick")
            result.amount = _op_data.get("amt")
        return result
